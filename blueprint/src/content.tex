% !TEX root =blueprint/src/print.tex
% In this file you should put the actual content of the blueprint.
% It will be used both by the web and the print version.
% It should *not* include the \begin{document}
%
% If you want to split the blueprint content into several files then
% the current file can be a simple sequence of \input. Otherwise It
% can start with a \section or \chapter for instance.

\chapter{Gray Code Fundamentals}

\begin{definition}
    If $x$ is a natural number, then let $(x)_i$ be $x$'s $i$th digit when expanded in binary.
    \label{def:test_digit}
    \lean{Nat.testBit}
    \leanok
\end{definition}

\begin{definition}
    \label{def:next_to}
    \lean{next_to}
    \leanok
    A natural number $x$ is \textbf{next to} $y$ if $(x)_i = (y)_i$ for all $i$ except some $j$.
\end{definition}

\begin{theorem}
    \label{thm:bitwise_test_power_of_two}
    \lean{bitwise_test_power_of_two}
    \leanok
    We can test if $x$ is a power of $2$ by making sure $x$ isn't 0 and then checking $x \& (x - 1) = 0$.
\end{theorem}

\begin{proof}
    \leanok
    %Note that $2^k - 1 = 1 + \cdots + 2^{k-1}$. Thus $(2^k - 1)_i = 1$ for
    %all $i \le {k-1}$.

    When $x = 2^k$, since $(x)_k = 1$ and all others are $0$, while $(x - 1)_k = 1$ for all $i \le k-1$ and $0$ otherwise. Thus $x \& (x - 1) = 0$ and we return true.

    If $x = 0$, then we return false correctly.
    
    Suppose that $2^i < x < 2^{i+1}$, then $(x)_i = 1$ and $2^i \le (x - 1) < 2^{i-1}$,
    so thus $(x-1)_i = 1$. Thus $x \& (x - 1) \neq 0$.
\end{proof}

\begin{theorem}
    \label{thm:next_to_xor_two_pow}
    \lean{next_to_xor_two_pow}
    \uses{def:next_to}
    \leanok
    We can test if $x$ is next to $y$ by looking at $x \oplus y$. If $x \oplus y$ is a
    power of two, then $x$ is next to $y$.

    Similarly, the $x \oplus 2^n$ is next to $x$ for any $x$.
\end{theorem}

\begin{proof}
    \leanok
    $x$ is next to $y$ iff there is some $i$ alone where they are different.
    This occurs iff $(x \oplus y)_i = (x)_i \oplus (y)_i = 1$ only for $i$.
    $(x \oplus y)_i$ for only $i$ iff $(x \oplus y) = 2^i$.
\end{proof}

\begin{definition}
    \label{def:computable_next_to}
    \lean{Computable.next_to}
    \leanok
    \uses{thm:bitwise_test_power_of_two,thm:next_to_xor_two_pow}

    This gives us a computable and equivalent definition of \textbf{next to}.
\end{definition}

\begin{definition}
    \label{def:unit_step_sequence}
    \lean{IsUnitStepSeq}
    \leanok
    \uses{def:next_to}
    A sequence $X_i$ of natural numbers $\mathbb{N}$ is a "unit step sequence" if
    for all $i$, $X_i$ is next to $X_{i+1}$.
\end{definition}

\begin{definition}
    \label{def:gray_code}
    \lean{IsGrayCode}
    \leanok
    \uses{def:unit_step_sequence}

    A gray code is an injective unit step sequence (and preferably with a nice image).
\end{definition}

\begin{definition}
    \label{def:list_gray_code}
    \lean{list_gray_code}
    \leanok

    We can define a sequence $L_n(i)$ of naturals of length $2^n$ by iteratively concatenating
    a reversed copy of the previous iteration and adding/xoring $2^{n-1}$ to each element.
    We start with $[0]$, then $[0, 1]$, then $[0, 1, 3, 2]$, and so on.
\end{definition}

\begin{theorem}
    \label{thm:list_is_stable}
    %\lean{list_is_stable}
    \uses{def:list_gray_code}

    Let $L_n$ be the $n$th iteration of the list, then $\forall m \ge n$, $L_n(i) = L_m(i)$ for all $i < 2^n$.
\end{theorem}

\begin{proof}
    Trivial.
\end{proof}

\begin{theorem}
    \label{thm:recursion_principle}
    %\lean{two_pow_complement_induction}

    In order to translate our sequence into an index based inductive principle instead:
    
    If $P(0)$ is true, and $\forall n, \forall 2^n \le i < 2^{n+1}, P((2^{n+1} - 1) \oplus i) \to P(i)$, then
    $P$ true for all $n$
\end{theorem}

\begin{proof}
    When $2^n \le i < 2^{n+1}$, then $i \oplus (2^{n+1} - 1) < 2^n$, so
    the sequence decreases.
\end{proof}

\begin{definition}
    \label{def:recursive_gray_code}
    %\lean{recursive_gray_code}

    \uses{thm:recursion_principle}
    There is a sequence $x$ that is a defined using $2^n \le i < 2^{n+1}$, $x_i = 2^n \oplus x_{(2^{n+1} - 1) \oplus i}$
    and $x_0 = 0$.
\end{definition}

\begin{theorem}
    \label{thm:list_is_recursive}
    %\lean{list_is_recursive}
    \uses{def:list_gray_code,def:recursive_gray_code}

    We can see that $x_i = L_n(i)$ for all $i < 2^n$. 
\end{theorem}

\begin{proof}
    \uses{thm:recursion_principle,thm:list_is_stable}
    We will prove this by showing that $L_n$ has the same induction property as $x$.

    Note that if $L_{n+1}$ is the $(n+1)$th list and $L_n$ is the $n$th list, $L_{n+1} = L_n \cdot (2^n \oplus \mathrm{reverse}(L_n))$. Thus
    \begin{align*}
    L_{n+1}(i) &= (L_n \cdot (2^n \oplus \mathrm{reverse}(L_n)))(i) \\
        &= (2^n \oplus \mathrm{reverse}(L_n))(i - 2^n) \\
        &= 2^n \oplus (\mathrm{reverse}(L_n))(i \oplus 2^n) \\
        &= 2^n \oplus L_n(i \oplus 2^n \oplus (2^n - 1)) \\
        &= 2^n \oplus L_n({i \oplus (2^{n+1} - 1)})
    \end{align*}

    Now assuming that $L_n(i) = x_i$ for all $i < 2^n$, since $i \oplus (2^{n+1} - 1) < 2^n$, we have
    $x_i = 2^n \oplus x_{i \oplus (2^{n+1} - 1)} = L_{n+1}(i)$.
\end{proof}

\begin{lemma}
    \label{thm:reverse_unit_step}
    \uses{def:unit_step_sequence}
    The reverse of a unit step list is also a unit step sequence.
\end{lemma}

\begin{proof}
    Trivial.
\end{proof}

\begin{theorem}
    \label{thm:list_gray_code_unit_step}
    %\lean{list_gray_code_unit_step}
    \uses{def:list_gray_code,def:unit_step_sequence}

    Each list $L_n$ is a unit step sequence on $\mathbb{Z} / 2^n \mathbb{Z}$.
\end{theorem}

\begin{proof}
    \uses{thm:next_to_xor_two_pow,thm:reverse_unit_step,thm:list_is_stable}
    It is obviously true for $n = 0$.

    By the stability property, $L_{n+1}$ is a unit step sequence for $i, i+1 < 2^n$.

    Since the reverse of a unit step sequence is a unit step sequence, then for
    $2^n \le i, i+1 < 2^{n+1}$, $L_{n+1}$ is a unit step sequence there as well.

    When $i = 2^n - 1$, then $L_{n+1}(2^n - 1) = L_{n}(2^n - 1)$ and $L_{n+1}(2^n) = 2^n \oplus L_{n}(2^n - 1)$,
    so thus $L_{n+1}(2^n - 1) \oplus L_{n+1}(2^n) = 2^n$ and they are next to each other.

    When $i = 2^{n+1} - 1$, then $L_{n+1}(2^{n+1} - 1) = 2^n \oplus L_{n}(0) = L_{n+1}(0)$ so thus they are next to each other.
\end{proof}

\begin{theorem}
    \label{thm:recursive_gray_code_unit_step}
    %\lean{recursive_gray_code_unit_step}

    \uses{def:recursive_gray_code}

    The recursive gray code is in fact a unit step sequence.
\end{theorem}

\begin{proof}
    \uses{thm:list_gray_code_unit_step,thm:list_is_recursive}
    Trivial application of the previous theorem.
\end{proof}

\begin{definition}
    \label{def:direct_gray_code}
    %\lean{direct_gray_code}
    We can also construct the same Gray code simply by doing $n \oplus (n >>> 1)$.
\end{definition}

\begin{theorem}
    \label{thm:direct_is_xor_homomorphism}

    \uses{def:direct_gray_code}
    From the direct gray code, it is obvious that $f(i \oplus j) = f(i) \oplus f(j)$.
\end{theorem}

\begin{proof}
    Trivial.
\end{proof}

\begin{theorem}
    \label{def:direct_is_recursive}
    %\lean{direct_is_recursive}
    \uses{def:unit_step_sequence,def:recursive_gray_code,def:direct_gray_code}

    This is eqvuivalent to the recursive definition.
\end{theorem}

\begin{proof}
    \uses{thm:recursion_principle}
    We shall prove this using the same induction principle.

    It is obviously true for $n = 0$.

    Let $2^n \le j < 2^{n+1}$ and let $i = (j \oplus (2^{n+1} - 1))$.
    Then we want to prove that $x_{i \oplus (2^{n+1} - 1)} = (i \oplus (2^{n+1} - 1)) \oplus ((i \oplus (2^{n+1} - 1)) >>> 1)$
    given that $x_i = i \oplus (i >>> 1)$.

    This amounts to a bunch of bitwise definitions:
    \begin{align*}
        (i \oplus (2^{n+1} - 1)) \oplus ((i \oplus (2^{n+1} - 1)) >>> 1)
        &= (2^{n+1} - 1) \oplus i \oplus (i >>> 1) \oplus ((2^{n+1} - 1) >>> 1) \\
        &= (2^{n+1} - 1) \oplus x_i \oplus (2^{n} - 1) \\
        &= 2^n \oplus x_i \\
        &= x_{i \oplus (2^{n+1} - 1)} 
    \end{align*}
\end{proof}


\begin{definition}
    \label{def:recursive_inverse}
    %\lean{recursive_inverse}
    We can also find an inverse to $x$ with recursion.

    For $i = 0$, $y_0 = 0$. For $2^n \le i < 2^{n+1}$, then $y_i = (2^{n+1} - 1) \oplus y_{i \oplus 2^n}$.

    Similarly we can have a recursion principle since $i \oplus 2^n$ is smaller than $i$.
\end{definition}

\begin{theorem}
    \label{thm:recursive_inverse_is_inverse}
    %\lean{recursive_inverse_is_inverse}
    \uses{def:recursive_inverse,def:recursive_gray_code}
    Now we must prove that $y_{x_i} = x_{y_i} = i$.
\end{theorem}

\begin{proof}
    \uses{thm:recursion_principle,def:recursive_gray_code,def:recursive_inverse}
    First, we'll show that $y_{x_{i}} = i$ by induction using $x$'s induction principle.
    When $i = 0$, $y_{x_0} = y_0 = 0$. If $2^n \le i < 2^{n+1}$, then $2^n \le x_i < 2^{n+1}$.
    So $y_{x_i} = (2^{n+1} - 1) \oplus y_{x_i \oplus 2^n}$. Since $x_i = 2^n \oplus x_{i \oplus (2^{n+1} - 1)}$ and $y_{x_{i \oplus (2^{n+1} - 1)}} = i \oplus (2^{n+1} - 1)$ from the induction principle:
    \begin{align*}
        y_{x_i} &= (2^{n+1} - 1) \oplus y_{x_i \oplus 2^n} = (2^{n+1} - 1) \oplus y_{x_{i \oplus (2^{n+1} - 1)}} \\
        &= (2^{n+1} - 1) \oplus (i \oplus (2^{n+1} - 1)) = i
    \end{align*}

    For the reverse direction, we use $y$'s induction principle.
    When $i = 0$, $x_{y_0} = 0$. For $2^n \le i < 2^{n+1}$, we have $2^n \le y_i < 2^{n+1}$.
    Similar to before, we will apply the induction principle in a sequence of calculations whil unfolding $x$.

    \begin{align*}
        x_{y_i} &= 2^n \oplus x_{y_i \oplus (2^{n+1} - 1)} = 2^n \oplus x_{y_{i \oplus 2^n}} \\
        &= 2^n \oplus i \oplus 2^n = i
    \end{align*}
\end{proof}

\begin{definition}
    \label{def:computable_inverse}
    %\lean{computable_inverse}
    
    Let $m = n$. While $m > 0$, let $m := m >> 1$ and $n := n \oplus m$.
    At the end, $n$ will be equal to the inverse $y_i$.

    We can implement this recursively by descent on $m, m/2, \ldots$.
\end{definition}

\begin{theorem}
    \label{thm:computable_inverse_is_equivalent}
    %\lean{computable_inverse_is_equivalent}
    \uses{def:recursive_inverse,def:computable_inverse}

    The above procedure is equivalent to the recursive definition of $y$.
\end{theorem}

\begin{proof}
    \uses{thm:recursion_principle,def:recursive_gray_code,def:recursive_inverse}
    Let the procedure be called $f$.

    Once again, we prove this by induction on $y$'s recursive principle. The base case is obvious.

    First, prove by induction on $m$ that $f(x \oplus y) = f(x) \oplus f(y)$. Then show that
    $f(2^n) = 2^{n+1} - 1$. This gives that $f(x) = f(x \oplus 2^n) \oplus (2^{n+1} - 1)$.
    By the inductive hypothesis, we are complete, since this is the same induction principle as $y$.
\end{proof}

\begin{theorem}
    \label{thm:recursive_is_gray_code}
    \uses{def:recursive_gray_code,def:gray_code}
    The recursive sequence is a gray code.
\end{theorem}

\begin{proof}
    \uses{thm:recursive_gray_code_unit_step,def:gray_code,thm:recursive_inverse_is_inverse}
    Invertibility and unit step sequence 
\end{proof}
